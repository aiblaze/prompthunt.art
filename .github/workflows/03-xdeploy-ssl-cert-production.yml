# ============================================================================
# XDeploy SSL 证书管理工作流
# ============================================================================
#
# 功能说明：
#   - 自动申请和续期 Let's Encrypt SSL 证书
#   - 支持通配符域名证书申请
#   - 自动部署证书到多台服务器
#   - 定时检查证书有效期并自动续期
#
# 使用场景：
#   - 首次申请域名 SSL 证书
#   - 定时自动续期即将过期的证书
#   - 强制重新生成证书
#   - 多服务器证书同步部署
#
# 触发方式：
#   - 定时任务：每月 1 日和 15 日凌晨 2 点自动运行
#   - 手动触发：支持强制重新生成证书选项
#
# 前置条件：
#   - 需要配置域名 DNS API 凭据（支持阿里云）
#   - 域名解析需要指向服务器
#   - SSH 密钥已配置
#
# 支持的 DNS 提供商：
#   - 阿里云 DNS（需配置 Access Key）
#   - 可扩展支持其他 DNS 提供商
#
# 证书管理功能：
#   - DNS-01 挑战验证
#   - 通配符证书支持
#   - 证书有效期检查
#   - 多服务器证书同步
#   - 证书部署验证
#
# ============================================================================

name: 03-XDeploySSLCert-production

on:
  schedule:
    # 每月 1 日和 15 日的凌晨 2 点运行
    - cron: '0 2 1,15 * *'
  workflow_dispatch:
    inputs:
      force_renewal:
        description: 强制重新生成证书 (即使证书未过期)
        required: false
        default: false
        type: boolean

env:
  TMP_CERT_DIR: /tmp/certs/live # 证书临时存储目录
  WORKFLOW_SCRIPTS_DIR: ${{ github.workspace }}/.xdeploy/production/scripts/workflows
  WORKFLOW_UTILS_DIR: ${{ github.workspace }}/.xdeploy/production/scripts/workflows/utils
  DEPLOY_SCRIPTS_DIR: ${{ github.workspace }}/.xdeploy/production/scripts/server
  DEPLOY_CONFIGS_DIR: ${{ github.workspace }}/.xdeploy/production/configs

jobs:
  generate-cert:
    environment: production
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set deployment environment
        id: set-env
        run: |
          ENV="${{ vars.XDP_DEPLOY_ENV || 'production' }}"
          echo "DEPLOY_ENV=$ENV" >> "$GITHUB_OUTPUT"
          echo "使用部署环境: $ENV"

      - name: Setup script environment
        run: |
          # 确保所有脚本有执行权限
          chmod +x ${WORKFLOW_SCRIPTS_DIR}/*.sh
          chmod +x ${WORKFLOW_UTILS_DIR}/*.sh
          chmod +x ${DEPLOY_SCRIPTS_DIR}/*.sh

      - name: Set SSL parameters
        id: ssl-params
        run: |
          if [ -n "${{ vars.XDP_CERTBOT_DOMAIN_ARG }}" ]; then
            echo "DOMAIN_ARG=${{ vars.XDP_CERTBOT_DOMAIN_ARG }}" >> "$GITHUB_OUTPUT"
          else
            echo "::error::未提供域名参数。请在 production 环境变量中设置 XDP_CERTBOT_DOMAIN_ARG。"
            exit 1
          fi

          if [ -n "${{ vars.XDP_CERTBOT_EMAIL }}" ]; then
            echo "EMAIL=${{ vars.XDP_CERTBOT_EMAIL }}" >> "$GITHUB_OUTPUT"
          else
            echo "::error::未提供邮箱。请在 production 环境变量中设置 XDP_CERTBOT_EMAIL。"
            exit 1
          fi

          # 调用辅助脚本提取域名
          source ${WORKFLOW_UTILS_DIR}/index.sh
          BASE_DOMAIN=$(extract_domain "${{ vars.XDP_CERTBOT_DOMAIN_ARG }}")
          EXTRACT_STATUS=$?

          # 检查提取结果
          if [ $EXTRACT_STATUS -ne 0 ]; then
            echo "::error::域名参数错误: $BASE_DOMAIN"
            exit 1
          fi

          echo "BASE_DOMAIN=$BASE_DOMAIN" >> "$GITHUB_OUTPUT"

      - name: Set servers
        id: set-servers
        run: |
          if [ -n "${{ vars.XDP_SERVERS }}" ]; then
            echo "SERVERS=${{ vars.XDP_SERVERS }}" >> "$GITHUB_OUTPUT"
          else
            echo "::error::未提供服务器列表。请在 production 环境变量中设置 XDP_SERVERS。"
            exit 1
          fi

      - name: Set Aliyun credentials
        id: set-aliyun-credentials
        if: ${{ vars.XDP_CERTBOT_CLOUD_PROVIDER == 'aliyun' }}
        run: |
          if [ -z "${{ secrets.XDS_CERTBOT_ALIYUN_REGION }}" ] || [ -z "${{ secrets.XDS_CERTBOT_ALIYUN_ACCESS_KEY_ID }}" ] || [ -z "${{ secrets.XDS_CERTBOT_ALIYUN_ACCESS_KEY_SECRET }}" ]; then
            echo "::error::未提供阿里云凭据。请在 production 环境密钥中设置 XDS_CERTBOT_ALIYUN_REGION、XDS_CERTBOT_ALIYUN_ACCESS_KEY_ID 和 XDS_CERTBOT_ALIYUN_ACCESS_KEY_SECRET。"
            exit 1
          fi
          echo "阿里云凭据已配置。"

      - name: Create certificate directory
        run: mkdir -p ${{ env.TMP_CERT_DIR }}

      - name: Check existing certificates
        id: check-certs
        if: ${{ github.event.inputs.force_renewal != 'true' }}
        run: |
          # 调用证书检查脚本
          ${WORKFLOW_SCRIPTS_DIR}/cert-check.sh \
            "$(echo "${{ steps.set-servers.outputs.SERVERS }}" | cut -d',' -f1)" \
            "${{ steps.ssl-params.outputs.BASE_DOMAIN }}" \
            "${{ vars.XDP_CERT_DIR }}" \
            "${{ env.TMP_CERT_DIR }}" \
            "${{ secrets.XDS_SSH_PRIVATE_KEY }}"

      - name: Generate new SSL certificate
        id: generate-cert
        if: ${{ github.event.inputs.force_renewal == 'true' || steps.check-certs.outputs.cert_status == 'missing' }}
        run: |
          # 调用证书生成脚本
          ${WORKFLOW_SCRIPTS_DIR}/cert-generate.sh \
            "${{ steps.ssl-params.outputs.DOMAIN_ARG }}" \
            "${{ steps.ssl-params.outputs.EMAIL }}" \
            "${{ vars.XDP_CERTBOT_DNS_PROPAGATION_SECONDS }}" \
            "${{ github.event.inputs.force_renewal }}" \
            "${{ env.TMP_CERT_DIR }}" \
            "${{ env.DEPLOY_CONFIGS_DIR }}/xcertbot.env" \
            "${{ secrets.XDS_CERTBOT_ALIYUN_REGION }}" \
            "${{ secrets.XDS_CERTBOT_ALIYUN_ACCESS_KEY_ID }}" \
            "${{ secrets.XDS_CERTBOT_ALIYUN_ACCESS_KEY_SECRET }}" \
            "generate"

      - name: Renew SSL certificate
        id: renew-cert
        if: ${{ steps.check-certs.outputs.cert_status == 'expiring' }}
        run: |
          # 确保脚本有执行权限
          chmod +x ${WORKFLOW_SCRIPTS_DIR}/cert-generate.sh

          # 调用证书生成脚本（续期模式）
          ${WORKFLOW_SCRIPTS_DIR}/cert-generate.sh \
            "${{ steps.ssl-params.outputs.DOMAIN_ARG }}" \
            "${{ steps.ssl-params.outputs.EMAIL }}" \
            "${{ vars.XDP_CERTBOT_DNS_PROPAGATION_SECONDS }}" \
            "${{ github.event.inputs.force_renewal }}" \
            "${{ env.TMP_CERT_DIR }}" \
            "${{ env.DEPLOY_CONFIGS_DIR }}/xcertbot.env" \
            "${{ secrets.XDS_CERTBOT_ALIYUN_REGION }}" \
            "${{ secrets.XDS_CERTBOT_ALIYUN_ACCESS_KEY_ID }}" \
            "${{ secrets.XDS_CERTBOT_ALIYUN_ACCESS_KEY_SECRET }}" \
            "renew"

      - name: Install SSH key
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.XDS_SSH_PRIVATE_KEY }}
          known_hosts: placeholder # 将在下一步中填充
          if_key_exists: replace

      - name: Deploy certificates to servers
        id: deploy
        if: ${{ steps.generate-cert.outputs.cert_updated == 'true' || steps.renew-cert.outputs.cert_updated == 'true' }}
        run: |
          # 再次检查证书是否存在
          if [ ! -d "${{ env.TMP_CERT_DIR }}" ] || [ ! "$(ls -A ${{ env.TMP_CERT_DIR }})" ]; then
            echo "::error::证书目录为空，无法部署"
            exit 1
          fi

          # 分割服务器列表
          IFS=',' read -ra SERVER_ARRAY <<< "${{ steps.set-servers.outputs.SERVERS }}"

          # 部署到每个服务器
          for server in "${SERVER_ARRAY[@]}"; do
            # 调用证书部署脚本
            ${WORKFLOW_SCRIPTS_DIR}/cert-deploy.sh \
              "$server" \
              "${{ vars.XDP_CERT_DIR }}" \
              "${{ env.TMP_CERT_DIR }}" \
              "${{ env.DEPLOY_SCRIPTS_DIR }}" \
              "${{ secrets.XDS_SSH_PRIVATE_KEY }}" \
              "${{ steps.ssl-params.outputs.BASE_DOMAIN }}"
          done

      - name: Sync certificates to other servers
        id: sync-cert
        if: ${{ steps.check-certs.outputs.cert_status == 'valid' || steps.generate-cert.outputs.cert_updated == 'true' || steps.renew-cert.outputs.cert_updated == 'true' }}
        run: |
          # 获取服务器列表
          IFS=',' read -ra SERVER_ARRAY <<< "${{ steps.set-servers.outputs.SERVERS }}"

          # 如果有多台服务器，则将第一台服务器的证书同步到其他服务器
          if [ ${#SERVER_ARRAY[@]} -gt 1 ]; then
            echo "检测到多台服务器，将第一台服务器的证书同步到其他服务器..."

            # 第一台服务器（主节点）
            PRIMARY_SERVER="${SERVER_ARRAY[0]}"
            SYNC_SUCCESS=true
            SYNC_SKIPPED_COUNT=0
            SYNC_COMPLETED_COUNT=0

            # 确定是否需要强制同步
            FORCE_SYNC="false"
            if [ "${{ steps.generate-cert.outputs.cert_updated }}" == "true" ] || [ "${{ steps.renew-cert.outputs.cert_updated }}" == "true" ]; then
              FORCE_SYNC="true"
              echo "检测到证书已更新，将强制同步到所有服务器"
            fi

            # 同步到其他服务器
            for ((i=1; i<${#SERVER_ARRAY[@]}; i++)); do
              TARGET_SERVER="${SERVER_ARRAY[$i]}"

              echo "正在处理服务器: $TARGET_SERVER"

              # 调用证书同步脚本
              if ${WORKFLOW_SCRIPTS_DIR}/cert-sync.sh \
                "$PRIMARY_SERVER" \
                "$TARGET_SERVER" \
                "${{ vars.XDP_CERT_DIR }}" \
                "${{ steps.ssl-params.outputs.BASE_DOMAIN }}" \
                "${{ env.DEPLOY_SCRIPTS_DIR }}" \
                "${{ secrets.XDS_SSH_PRIVATE_KEY }}" \
                "$FORCE_SYNC"; then

                # 检查是否跳过了同步
                if [ -f "$GITHUB_OUTPUT" ] && grep -q "sync_skipped=true" "$GITHUB_OUTPUT"; then
                  echo "服务器 $TARGET_SERVER 的证书已是最新，跳过同步"
                  SYNC_SKIPPED_COUNT=$((SYNC_SKIPPED_COUNT + 1))
                else
                  echo "服务器 $TARGET_SERVER 证书同步成功"
                  SYNC_COMPLETED_COUNT=$((SYNC_COMPLETED_COUNT + 1))
                fi
              else
                echo "::error::服务器 $TARGET_SERVER 证书同步失败"
                SYNC_SUCCESS=false
              fi
            done

            # 输出同步摘要
            echo "证书同步摘要："
            echo "- 总服务器数: $((${#SERVER_ARRAY[@]} - 1))"
            echo "- 同步完成: $SYNC_COMPLETED_COUNT"
            echo "- 跳过同步: $SYNC_SKIPPED_COUNT"

            if [ "$SYNC_SUCCESS" = true ]; then
              echo "所有服务器证书处理完成"
            else
              echo "::error::部分服务器证书同步失败"
              exit 1
            fi
          else
            echo "只有一台服务器，无需同步证书"
          fi

      - name: Verify certificate deployment
        id: verify-cert
        if: ${{ steps.generate-cert.outputs.cert_updated == 'true' || steps.renew-cert.outputs.cert_updated == 'true' || steps.sync-cert.outputs.cert_synced == 'true' }}
        run: |
          # 获取第一个服务器
          SERVER=$(echo "${{ steps.set-servers.outputs.SERVERS }}" | cut -d',' -f1)

          # 调用证书验证脚本
          ${WORKFLOW_SCRIPTS_DIR}/cert-verify.sh \
            "$SERVER" \
            "${{ vars.XDP_CERT_DIR }}" \
            "${{ steps.ssl-params.outputs.BASE_DOMAIN }}" \
            "${{ secrets.XDS_SSH_PRIVATE_KEY }}"

      - name: Certificate Summary
        run: |
          # 确定操作类型
          if [ "${{ github.event.inputs.force_renewal }}" == "true" ]; then
            OPERATION_TYPE="force_renewal"
          elif [ "${{ steps.check-certs.outputs.cert_status }}" == "missing" ]; then
            OPERATION_TYPE="missing"
          elif [ "${{ steps.check-certs.outputs.cert_status }}" == "expiring" ]; then
            OPERATION_TYPE="expiring"
          elif [ "${{ steps.check-certs.outputs.cert_status }}" == "valid" ]; then
            OPERATION_TYPE="valid"
          else
            OPERATION_TYPE="unknown"
          fi

          # 调用证书摘要脚本
          ${WORKFLOW_SCRIPTS_DIR}/cert-summary.sh \
            "${OPERATION_TYPE}" \
            "${{ steps.ssl-params.outputs.DOMAIN_ARG }}" \
            "${{ steps.ssl-params.outputs.BASE_DOMAIN }}" \
            "${{ steps.set-servers.outputs.SERVERS }}" \
            "${{ vars.XDP_APP_DEPLOY_DIR }}" \
            "${{ vars.XDP_CERT_DIR }}"

      - name: Clean up sensitive files
        if: always()
        run: |
          # 调用清理脚本，这些文件是在 `cert-generate.sh` 中临时生成的
          ${WORKFLOW_SCRIPTS_DIR}/cert-cleanup.sh \
            "${GITHUB_WORKSPACE}/xcertbot.env" \
            "certbot_logs" \
            "${{ env.TMP_CERT_DIR }}"
